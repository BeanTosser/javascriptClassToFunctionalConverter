{"ast":null,"code":"import replaceStateModifier from \"./replaceStateModifier.js\";\nexport default function (componentString) {\n  // REGEX PATTERNS\n  var regexPatterns = {\n    classDeclarationRegex: /class ((\\w*|\\d*)+) extends React.Component *{ *\\n/gim,\n    // blah? remove outer constructor definition block and fix contents indentation accordingly\n    constructorRegex: /( *constructor\\(props\\) *{ *\\n)(?: *super\\(props\\);? *\\n)(((?: {2}).*\\n)*)/gim,\n    modifyStateRegex: /(?: *((this.state ?= ?{)|(this.setState\\({)) *\\n)((( *)([a-z]\\w*): (\\w*),? *\\s*)*)}\\)?;?\\n/g,\n    setStateRegex: /(?: *this.setState ?\\(\\s*{ *\\n)(( *)([a-z]\\w*): (\\w*),? *\\s*)*};?/,\n    setStateVarRegex: /([a-z])(\\w*): ([^\\s,]*),?/g,\n    useStateSetter: /set([a-z])\\w*/g\n  };\n  var replacements = {\n    classDeclarationReplacement: \"function $1(props) {\\n\",\n    constructorReplacement: \"$2\",\n    initializeStateReplacement: \"$1\",\n    initializeStateVariableReplacement: \"const [$1, set$1] = useState($2);\"\n  };\n\n  var replaceStateInitialization = function replaceStateInitialization(p1, p2, p3, p4) {\n    return \"const [\" + p2 + p3 + \", set\" + p2.toUpperCase() + p3 + \"] = useState(\" + p4 + \")\\n\";\n  }; //Replace class definition with function definition\n\n\n  componentString = componentString.replace(regexPatterns.classDeclarationRegex, replacements.classDeclarationReplacement); // Remove constructor declaration and its closing \"}\"\n\n  componentString = componentString.replace(regexPatterns.constructorRegex, replacements.constructorReplacement); // Store all instances of state modifying blocks in \"match\"\n\n  var matches = componentString.match(regexPatterns.modifyStateRegex); // Obtain the substring of each state-modifying block and pass it\n  // To the replaceStateModifier function\n\n  var lastMatchEndIndex = 0;\n  var componentStringSections = []; // used to build the final code string piece-by-piece\n\n  for (var i = 0; i < matches.length; i++) {\n    var matchStartPosition = componentString.indexOf(matches[i]);\n    var matchEndPosition = matchStartPosition + matches[i].length;\n    console.log(\"current match: \" + matches[i]); // Determine whether this block _initializes_ or _modifies_ state\n    //let isInitializer = matches[i].indexOf(\"setState\")\n\n    /*\r\n     * Add all the code between the end of the last matched (state-setting) section \r\n     * (or the beginning of the code) and the current one\r\n     */\n\n    componentStringSections.push(componentString.substring(lastMatchEndIndex, matchStartPosition));\n    lastMatchEndIndex = matchEndPosition;\n    var modifiedBlock = replaceStateModifier(matches[i], replaceStateInitialization);\n    componentStringSections.push(modifiedBlock); //Add the modified state-setting block to the final string\n  } // Insert the remaining unmodified code into the final assembled code string\n\n\n  componentStringSections.push(componentString.substring(lastMatchEndIndex));\n  componentString = componentStringSections;\n  return componentString;\n}","map":{"version":3,"sources":["/home/michael/git/javascriptClassToFunctionalConverter/src/Tools/classToFunctionalConverter.js"],"names":["replaceStateModifier","componentString","regexPatterns","classDeclarationRegex","constructorRegex","modifyStateRegex","setStateRegex","setStateVarRegex","useStateSetter","replacements","classDeclarationReplacement","constructorReplacement","initializeStateReplacement","initializeStateVariableReplacement","replaceStateInitialization","p1","p2","p3","p4","toUpperCase","replace","matches","match","lastMatchEndIndex","componentStringSections","i","length","matchStartPosition","indexOf","matchEndPosition","console","log","push","substring","modifiedBlock"],"mappings":"AAAA,OAAOA,oBAAP,MAAiC,2BAAjC;AAEA,eAAe,UAAUC,eAAV,EAA2B;AACxC;AACA,MAAMC,aAAa,GAAG;AACpBC,IAAAA,qBAAqB,EAAE,sDADH;AAEpB;AACAC,IAAAA,gBAAgB,EAAE,+EAHE;AAIpBC,IAAAA,gBAAgB,EAAE,6FAJE;AAKpBC,IAAAA,aAAa,EAAE,mEALK;AAMpBC,IAAAA,gBAAgB,EAAE,4BANE;AAOpBC,IAAAA,cAAc,EAAE;AAPI,GAAtB;AASA,MAAMC,YAAY,GAAG;AACnBC,IAAAA,2BAA2B,EAAE,wBADV;AAEnBC,IAAAA,sBAAsB,EAAE,IAFL;AAGnBC,IAAAA,0BAA0B,EAAE,IAHT;AAInBC,IAAAA,kCAAkC,EAAE;AAJjB,GAArB;;AAOA,MAAMC,0BAA0B,GAAG,SAA7BA,0BAA6B,CAAUC,EAAV,EAAcC,EAAd,EAAkBC,EAAlB,EAAsBC,EAAtB,EAA0B;AAC3D,WACE,YACAF,EADA,GAEAC,EAFA,GAGA,OAHA,GAIAD,EAAE,CAACG,WAAH,EAJA,GAKAF,EALA,GAMA,eANA,GAOAC,EAPA,GAQA,KATF;AAWD,GAZD,CAlBwC,CAgCxC;;;AACAjB,EAAAA,eAAe,GAAGA,eAAe,CAACmB,OAAhB,CAChBlB,aAAa,CAACC,qBADE,EAEhBM,YAAY,CAACC,2BAFG,CAAlB,CAjCwC,CAqCxC;;AACAT,EAAAA,eAAe,GAAGA,eAAe,CAACmB,OAAhB,CAChBlB,aAAa,CAACE,gBADE,EAEhBK,YAAY,CAACE,sBAFG,CAAlB,CAtCwC,CA2CxC;;AACA,MAAIU,OAAO,GAAGpB,eAAe,CAACqB,KAAhB,CAAsBpB,aAAa,CAACG,gBAApC,CAAd,CA5CwC,CA6CxC;AACA;;AACA,MAAIkB,iBAAiB,GAAG,CAAxB;AACA,MAAIC,uBAAuB,GAAG,EAA9B,CAhDwC,CAgDN;;AAClC,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,OAAO,CAACK,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;AAEvC,QAAIE,kBAAkB,GAAG1B,eAAe,CAAC2B,OAAhB,CAAwBP,OAAO,CAACI,CAAD,CAA/B,CAAzB;AACA,QAAII,gBAAgB,GAAGF,kBAAkB,GAAGN,OAAO,CAACI,CAAD,CAAP,CAAWC,MAAvD;AAEAI,IAAAA,OAAO,CAACC,GAAR,CAAY,oBAAoBV,OAAO,CAACI,CAAD,CAAvC,EALuC,CAOvC;AACA;;AAEA;AACJ;AACA;AACA;;AACID,IAAAA,uBAAuB,CAACQ,IAAxB,CACE/B,eAAe,CAACgC,SAAhB,CAA0BV,iBAA1B,EAA6CI,kBAA7C,CADF;AAIAJ,IAAAA,iBAAiB,GAAGM,gBAApB;AAEA,QAAIK,aAAa,GAAGlC,oBAAoB,CACtCqB,OAAO,CAACI,CAAD,CAD+B,EAEtCX,0BAFsC,CAAxC;AAOAU,IAAAA,uBAAuB,CAACQ,IAAxB,CAA6BE,aAA7B,EA3BuC,CA2BM;AAC9C,GA7EuC,CA+ExC;;;AACAV,EAAAA,uBAAuB,CAACQ,IAAxB,CAA6B/B,eAAe,CAACgC,SAAhB,CAA0BV,iBAA1B,CAA7B;AACAtB,EAAAA,eAAe,GAAGuB,uBAAlB;AACA,SAAOvB,eAAP;AACD","sourcesContent":["import replaceStateModifier from \"./replaceStateModifier.js\";\r\n\r\nexport default function (componentString) {\r\n  // REGEX PATTERNS\r\n  const regexPatterns = {\r\n    classDeclarationRegex: /class ((\\w*|\\d*)+) extends React.Component *{ *\\n/gim,\r\n    // blah? remove outer constructor definition block and fix contents indentation accordingly\r\n    constructorRegex: /( *constructor\\(props\\) *{ *\\n)(?: *super\\(props\\);? *\\n)(((?: {2}).*\\n)*)/gim,\r\n    modifyStateRegex: /(?: *((this.state ?= ?{)|(this.setState\\({)) *\\n)((( *)([a-z]\\w*): (\\w*),? *\\s*)*)}\\)?;?\\n/g,\r\n    setStateRegex: /(?: *this.setState ?\\(\\s*{ *\\n)(( *)([a-z]\\w*): (\\w*),? *\\s*)*};?/,\r\n    setStateVarRegex: /([a-z])(\\w*): ([^\\s,]*),?/g,\r\n    useStateSetter: /set([a-z])\\w*/g\r\n  };\r\n  const replacements = {\r\n    classDeclarationReplacement: \"function $1(props) {\\n\",\r\n    constructorReplacement: \"$2\",\r\n    initializeStateReplacement: \"$1\",\r\n    initializeStateVariableReplacement: \"const [$1, set$1] = useState($2);\"\r\n  };\r\n\r\n  const replaceStateInitialization = function (p1, p2, p3, p4) {\r\n    return (\r\n      \"const [\" +\r\n      p2 +\r\n      p3 +\r\n      \", set\" +\r\n      p2.toUpperCase() +\r\n      p3 +\r\n      \"] = useState(\" +\r\n      p4 +\r\n      \")\\n\"\r\n    );\r\n  };\r\n\r\n  //Replace class definition with function definition\r\n  componentString = componentString.replace(\r\n    regexPatterns.classDeclarationRegex,\r\n    replacements.classDeclarationReplacement\r\n  );\r\n  // Remove constructor declaration and its closing \"}\"\r\n  componentString = componentString.replace(\r\n    regexPatterns.constructorRegex,\r\n    replacements.constructorReplacement\r\n  );\r\n\r\n  // Store all instances of state modifying blocks in \"match\"\r\n  let matches = componentString.match(regexPatterns.modifyStateRegex);\r\n  // Obtain the substring of each state-modifying block and pass it\r\n  // To the replaceStateModifier function\r\n  let lastMatchEndIndex = 0;\r\n  let componentStringSections = []; // used to build the final code string piece-by-piece\r\n  for (let i = 0; i < matches.length; i++) {\r\n    \r\n    let matchStartPosition = componentString.indexOf(matches[i]);\r\n    let matchEndPosition = matchStartPosition + matches[i].length;\r\n    \r\n    console.log(\"current match: \" + matches[i]);\r\n    \r\n    // Determine whether this block _initializes_ or _modifies_ state\r\n    //let isInitializer = matches[i].indexOf(\"setState\")\r\n    \r\n    /*\r\n     * Add all the code between the end of the last matched (state-setting) section \r\n     * (or the beginning of the code) and the current one\r\n     */\r\n    componentStringSections.push(\r\n      componentString.substring(lastMatchEndIndex, matchStartPosition)\r\n    );\r\n\r\n    lastMatchEndIndex = matchEndPosition;\r\n\r\n    let modifiedBlock = replaceStateModifier(\r\n      matches[i],\r\n      replaceStateInitialization\r\n    );\r\n    \r\n    \r\n    \r\n    componentStringSections.push(modifiedBlock); //Add the modified state-setting block to the final string\r\n  }\r\n  \r\n  // Insert the remaining unmodified code into the final assembled code string\r\n  componentStringSections.push(componentString.substring(lastMatchEndIndex));\r\n  componentString = componentStringSections;\r\n  return componentString;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}